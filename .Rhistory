"'graph' must be directed when 'dir_fragmentation_type' or 'dir_distance_type' are set to 'asymmetric'")
if( weight %in% igraph::edge_attr_names(graph) ) stop(
"'weight' argument must not be a edge attribute in 'graph'")
if( field_B %in% igraph::edge_attr_names(graph) ) stop(
"'field_B' argument must not be a edge attribute in 'graph'")
# What happens if B_ij_flag is false? suppress further warnings
if(B_ij_flag == FALSE) {param_u = param_d = param <- NA}
if(dir_distance_type == "symmetric") {param_u = param_d <- NA}
if(dir_distance_type == "asymmetric") {param  <- NA}
# Set the names of the vertices. By default keep the name argument.
igraph::V(graph)$name <- igraph::vertex_attr(graph, nodes_id)
# 1. Calculate c_ij (get arguments from index_calculation function)
if (c_ij_flag == TRUE) {
c_ij_mat <- c_ij_fun(graph,
dir_fragmentation_type = dir_fragmentation_type,
pass_confluence = pass_confluence,
pass_u = pass_u,
pass_d = pass_d)
}
# 2. Calculate B_ij  (get arguments from index_calculation function)
if (B_ij_flag == TRUE) {
B_ij_mat <- B_ij_fun(graph,
field_B = field_B,
dir_distance_type = dir_distance_type,
disp_type = disp_type,
param_u = param_u,
param_d = param_d,
param = param)
}
# 3. Aggregate results
if(c_ij_flag == TRUE & B_ij_flag == TRUE) {
agg_mat <- c_ij_mat %>%
dplyr::left_join(B_ij_mat, by = c("from", "to")) %>%
dplyr::mutate(P = .data$c_ij * .data$B_ij) }
if(c_ij_flag == TRUE & B_ij_flag == FALSE){
agg_mat <- c_ij_mat %>%
dplyr::mutate(P = .data$c_ij ) }
if(c_ij_flag == FALSE & B_ij_flag == TRUE) {
agg_mat <- B_ij_mat %>%
dplyr::mutate(P = .data$B_ij) }
# 4. Get the weight information
# Get vertices list from graph
g_v_df <- dplyr::rename_with(
igraph::as_data_frame(graph, what = "vertices"),
~"weight_node", contains(weight))
# Join probaility matrix with weight information
agg_mat <- agg_mat %>%
dplyr::left_join( g_v_df %>% dplyr::select(.data$name, .data$weight_node) %>%
dplyr::rename(from = .data$name, weight_from = .data$weight_node), by = "from"  ) %>%
dplyr::left_join( g_v_df %>% dplyr::select(.data$name, .data$weight_node) %>%
dplyr::rename(to = .data$name, weight_to = .data$weight_node), by = "to" )
c_ij_flag = TRUE
B_ij_flag = TRUE
# Error messages
if( !(index_type %in% c("full", "reach")) ) stop(
"'index_type' must me either 'full' or 'reach'")
if( index_type == "reach" & !(index_mode %in% c("from", "to")) ) stop(
"'index_mode' must me either 'from' or 'to'")
if( index_type == "reach" & missing(index_mode) ) stop(
"'index_mode' must me either defined when index_type = 'reach'")
if( !(weight %in% igraph::vertex_attr_names(graph)) ) stop(
"'weight' argument must be a valid vertex attribute in 'graph'")
if( !(nodes_id %in% igraph::vertex_attr_names(graph)) ) stop(
"'nodes_id' argument must be a valid vertex attribute in 'graph'")
if( !(c_ij_flag | B_ij_flag) ) stop(
"at least one among c_if and B_ij should be selected for calculations")
if( length(igraph::vertex_attr(graph, nodes_id)) < igraph::gorder(graph)  ) stop(
"'nodes_id' must be unique for each vertex")
if( !igraph::is_connected(graph)  ) stop(
"'graph' must be connected (check if some nodes are disconnected with igraph::components() )")
if( (dir_fragmentation_type == "asymmetric" |  dir_distance_type == "asymmetric") & igraph::is_directed(graph) == FALSE ) stop(
"'graph' must be directed when 'dir_fragmentation_type' or 'dir_distance_type' are set to 'asymmetric'")
if( weight %in% igraph::edge_attr_names(graph) ) stop(
"'weight' argument must not be a edge attribute in 'graph'")
if( field_B %in% igraph::edge_attr_names(graph) ) stop(
"'field_B' argument must not be a edge attribute in 'graph'")
# What happens if B_ij_flag is false? suppress further warnings
if(B_ij_flag == FALSE) {param_u = param_d = param <- NA}
if(dir_distance_type == "symmetric") {param_u = param_d <- NA}
if(dir_distance_type == "asymmetric") {param  <- NA}
# Set the names of the vertices. By default keep the name argument.
igraph::V(graph)$name <- igraph::vertex_attr(graph, nodes_id)
# 1. Calculate c_ij (get arguments from index_calculation function)
if (c_ij_flag == TRUE) {
c_ij_mat <- c_ij_fun(graph,
dir_fragmentation_type = dir_fragmentation_type,
pass_confluence = pass_confluence,
pass_u = pass_u,
pass_d = pass_d)
}
# 2. Calculate B_ij  (get arguments from index_calculation function)
if (B_ij_flag == TRUE) {
B_ij_mat <- B_ij_fun(graph,
field_B = field_B,
dir_distance_type = dir_distance_type,
disp_type = disp_type,
param_u = param_u,
param_d = param_d,
param = param)
}
# 3. Aggregate results
if(c_ij_flag == TRUE & B_ij_flag == TRUE) {
agg_mat <- c_ij_mat %>%
dplyr::left_join(B_ij_mat, by = c("from", "to")) %>%
dplyr::mutate(P = .data$c_ij * .data$B_ij) }
if(c_ij_flag == TRUE & B_ij_flag == FALSE){
agg_mat <- c_ij_mat %>%
dplyr::mutate(P = .data$c_ij ) }
if(c_ij_flag == FALSE & B_ij_flag == TRUE) {
agg_mat <- B_ij_mat %>%
dplyr::mutate(P = .data$B_ij) }
# Get vertices list from graph
g_v_df <- dplyr::rename_with(
igraph::as_data_frame(graph, what = "vertices"),
~"weight_node", contains(weight))
# Join probaility matrix with weight information
agg_mat <- agg_mat %>%
dplyr::left_join( g_v_df %>% dplyr::select(.data$name, .data$weight_node) %>%
dplyr::rename(from = .data$name, weight_from = .data$weight_node), by = "from"  ) %>%
dplyr::left_join( g_v_df %>% dplyr::select(.data$name, .data$weight_node) %>%
dplyr::rename(to = .data$name, weight_to = .data$weight_node), by = "to" )
library(riverconn)
library(rgdal)
library(shp2graph)
library(riverconn)
# 17.12.2021
am1<-as.matrix(read.table(file="adj_matrix.txt"))
g1<-graph_from_edgelist(am1)
plot(g1)
components(g1)
is_directed(g1)
vlength1<-read.table(file="centerpoint.txt",header=TRUE)
g2<-set_vertex_attr(g1, name='length', value=vlength1$length)
V(g2)$weight <- strength(g2)
E(g2)$passy<-as.numeric(0.5)
E(g2)$passx<-as.numeric(1)
g3<-set_vertex_attr(g2, name='label', value=paste(1:78))
g4<-set_edge_attr(g3, name='label', value=paste(1:77))
alpha.centrality(g4)
estimate_betweenness(g4, cutoff=1000)
index1<-index_calculation(g4, nodes_id="label", weight = "weight", index_type = "reach", pass_u = "passy",
pass_d = "passx", index_mode = "to", dir_fragmentation_type = "asymmetric",
pass_confluence = 1, field_B = "length", dir_distance_type = "symmetric",
disp_type = "exponential", param=0.5)
graph = g4
graph <- g4
nodes_id="label"
weight = "weight"
index_type = "reach"
pass_u = "passy"
pass_d = "passx"
index_mode = "to"
dir_fragmentation_type = "asymmetric"
pass_confluence = 1
field_B = "length"
dir_distance_type = "symmetric"
disp_type = "exponential"
param_u=0.5
param_d=1
# What happens if B_ij_flag is false? suppress further warnings
if(B_ij_flag == FALSE) {param_u = param_d = param <- NA}
if(dir_distance_type == "symmetric") {param_u = param_d <- NA}
if(dir_distance_type == "asymmetric") {param  <- NA}
# Set the names of the vertices. By default keep the name argument.
igraph::V(graph)$name <- igraph::vertex_attr(graph, nodes_id)
# 1. Calculate c_ij (get arguments from index_calculation function)
if (c_ij_flag == TRUE) {
c_ij_mat <- c_ij_fun(graph,
dir_fragmentation_type = dir_fragmentation_type,
pass_confluence = pass_confluence,
pass_u = pass_u,
pass_d = pass_d)
}
c_ij_flag = TRUE
B_ij_flag = TRUE
# Error messages
if( !(index_type %in% c("full", "reach")) ) stop(
"'index_type' must me either 'full' or 'reach'")
if( index_type == "reach" & !(index_mode %in% c("from", "to")) ) stop(
"'index_mode' must me either 'from' or 'to'")
if( index_type == "reach" & missing(index_mode) ) stop(
"'index_mode' must me either defined when index_type = 'reach'")
if( !(weight %in% igraph::vertex_attr_names(graph)) ) stop(
"'weight' argument must be a valid vertex attribute in 'graph'")
if( !(nodes_id %in% igraph::vertex_attr_names(graph)) ) stop(
"'nodes_id' argument must be a valid vertex attribute in 'graph'")
if( !(c_ij_flag | B_ij_flag) ) stop(
"at least one among c_if and B_ij should be selected for calculations")
if( length(igraph::vertex_attr(graph, nodes_id)) < igraph::gorder(graph)  ) stop(
"'nodes_id' must be unique for each vertex")
if( !igraph::is_connected(graph)  ) stop(
"'graph' must be connected (check if some nodes are disconnected with igraph::components() )")
if( (dir_fragmentation_type == "asymmetric" |  dir_distance_type == "asymmetric") & igraph::is_directed(graph) == FALSE ) stop(
"'graph' must be directed when 'dir_fragmentation_type' or 'dir_distance_type' are set to 'asymmetric'")
if( weight %in% igraph::edge_attr_names(graph) ) stop(
"'weight' argument must not be a edge attribute in 'graph'")
if( field_B %in% igraph::edge_attr_names(graph) ) stop(
"'field_B' argument must not be a edge attribute in 'graph'")
# What happens if B_ij_flag is false? suppress further warnings
if(B_ij_flag == FALSE) {param_u = param_d = param <- NA}
if(dir_distance_type == "symmetric") {param_u = param_d <- NA}
if(dir_distance_type == "asymmetric") {param  <- NA}
# Set the names of the vertices. By default keep the name argument.
igraph::V(graph)$name <- igraph::vertex_attr(graph, nodes_id)
# 1. Calculate c_ij (get arguments from index_calculation function)
if (c_ij_flag == TRUE) {
c_ij_mat <- c_ij_fun(graph,
dir_fragmentation_type = dir_fragmentation_type,
pass_confluence = pass_confluence,
pass_u = pass_u,
pass_d = pass_d)
}
# 2. Calculate B_ij  (get arguments from index_calculation function)
if (B_ij_flag == TRUE) {
B_ij_mat <- B_ij_fun(graph,
field_B = field_B,
dir_distance_type = dir_distance_type,
disp_type = disp_type,
param_u = param_u,
param_d = param_d,
param = param)
}
param = 0.5
dir_distance_type
# 2. Calculate B_ij  (get arguments from index_calculation function)
if (B_ij_flag == TRUE) {
B_ij_mat <- B_ij_fun(graph,
field_B = field_B,
dir_distance_type = dir_distance_type,
disp_type = disp_type,
param_u = param_u,
param_d = param_d,
param = param)
}
# 3. Aggregate results
if(c_ij_flag == TRUE & B_ij_flag == TRUE) {
agg_mat <- c_ij_mat %>%
dplyr::left_join(B_ij_mat, by = c("from", "to")) %>%
dplyr::mutate(P = .data$c_ij * .data$B_ij) }
if(c_ij_flag == TRUE & B_ij_flag == FALSE){
agg_mat <- c_ij_mat %>%
dplyr::mutate(P = .data$c_ij ) }
if(c_ij_flag == FALSE & B_ij_flag == TRUE) {
agg_mat <- B_ij_mat %>%
dplyr::mutate(P = .data$B_ij) }
# Get vertices list from graph
g_v_df <- dplyr::rename_with(
igraph::as_data_frame(graph, what = "vertices"),
~"weight_node", contains(weight))
# Join probaility matrix with weight information
agg_mat <- agg_mat %>%
dplyr::left_join( g_v_df %>% dplyr::select(.data$name, .data$weight_node) %>%
dplyr::rename(from = .data$name, weight_from = .data$weight_node), by = "from"  ) %>%
dplyr::left_join( g_v_df %>% dplyr::select(.data$name, .data$weight_node) %>%
dplyr::rename(to = .data$name, weight_to = .data$weight_node), by = "to" )
agg_mat <- agg_mat %>% mutate(prod = .data$P * .data$weight_from * .data$weight_to)
index_num <- sum( agg_mat$prod )
index_den <- ( sum( g_v_df$weight_node ) )^2
index = index_num / index_den
index <- data.frame("num" = index_num, "den" = index_den, "index" = index)
agg_mat <- agg_mat %>%
dplyr::mutate(prod = .data$P * .data$weight_from * .data$weight_to)
index_num <- sum( agg_mat$prod )
index_den <- ( sum( g_v_df$weight_node ) )^2
index = index_num / index_den
index <- data.frame("num" = index_num, "den" = index_den, "index" = index)
View(index)
index <- agg_mat %>%
dplyr::rename_with(~"weight", contains("weight_node") & !contains(index_mode)) %>%
dplyr::select(-matches(paste0("weight_",index_mode))) %>%
dplyr::rename_with(~nodes_id, contains("name") ) %>%
dplyr::rename_with(~ "weight_node", contains("weight_") ) %>%
dplyr::mutate(prod = .data$weight_node * .data$P) %>%
dplyr::group_by(.data$name) %>%
dplyr::summarize(num = sum(.data$prod)) %>%
dplyr::mutate(den = sum( g_v_df$weight_node ), index = .data$num/.data$den )
index <- agg_mat %>%
dplyr::rename_with(~"weight", contains("weight_node") & !contains(index_mode)) %>%
dplyr::select(-matches(paste0("weight_",index_mode))) %>%
#dplyr::rename_with(~nodes_id, contains("name") ) %>%
dplyr::rename_with(~ "weight_node", contains("weight_") ) %>%
dplyr::mutate(prod = .data$weight_node * .data$P) %>%
dplyr::group_by(.data$name) %>%
dplyr::summarize(num = sum(.data$prod)) %>%
dplyr::mutate(den = sum( g_v_df$weight_node ), index = .data$num/.data$den )
index <- agg_mat %>%
dplyr::rename_with(~"weight", contains("weight_node") & !contains(index_mode)) %>%
dplyr::select(-matches(paste0("weight_",index_mode)))
View(index)
index <- agg_mat %>%
dplyr::rename_with(~"weight", contains("weight_node") & !contains(index_mode)) %>%
dplyr::select(-matches(paste0("weight_",index_mode))) %>%
#dplyr::rename_with(~nodes_id, contains("name") ) %>%
dplyr::rename_with(~ "weight_node", contains("weight_") )
index <- agg_mat %>%
dplyr::rename_with(~"weight", contains("weight_node") & !contains(index_mode)) %>%
dplyr::select(-matches(paste0("weight_",index_mode))) %>%
#dplyr::rename_with(~nodes_id, contains("name") ) %>%
dplyr::rename_with(~ "weight_node", contains("weight_") ) %>%
dplyr::mutate(prod = .data$weight_node * .data$P) %>%
dplyr::group_by(.data$name) %>%
dplyr::summarize(num = sum(.data$prod)) %>%
dplyr::mutate(den = sum( g_v_df$weight_node ), index = .data$num/.data$den )
index <- agg_mat %>%
dplyr::rename_with(~"weight", contains("weight_node") & !contains(index_mode)) %>%
dplyr::select(-matches(paste0("weight_",index_mode))) %>%
dplyr::rename_with(~"name", contains(index_mode) ) %>%
dplyr::rename_with(~ "weight_node", contains("weight_") ) %>%
dplyr::mutate(prod = .data$weight_node * .data$P) %>%
dplyr::group_by(.data$name) %>%
dplyr::summarize(num = sum(.data$prod)) %>%
dplyr::mutate(den = sum( g_v_df$weight_node ), index = .data$num/.data$den )
View(index)
nodes_id
index <- agg_mat %>%
dplyr::rename_with(~"weight", contains("weight_node") & !contains(index_mode)) %>%
dplyr::select(-matches(paste0("weight_",index_mode))) %>%
dplyr::rename_with(~"name", contains(index_mode) ) %>%
dplyr::rename_with(~ "weight_node", contains("weight_") ) %>%
dplyr::mutate(prod = .data$weight_node * .data$P) %>%
dplyr::group_by(.data$name) %>%
dplyr::summarize(num = sum(.data$prod)) %>%
dplyr::mutate(den = sum( g_v_df$weight_node ), index = .data$num/.data$den ) %>%
dplyr::rename_with(~nodes_id, contains("name") )
library(riverconn)
knitr::opts_chunk$set(echo = TRUE)
library(igraph)
g <- graph_from_literal(1-+2, 2-+4, 3-+2, 4-+6, 6-+7, 5-+6, 7-+8, 9-+5, 10-+5 )
par(mfrow=c(1,2))
plot(g, layout = layout_as_tree(as.undirected(g), root = 8, flip.y = FALSE), main="Directed graph")
plot(as.undirected(g), layout = layout_as_tree(as.undirected(g), root = 8, flip.y = FALSE), main="Undirected graph")
library(igraph)
library(dplyr)
library(tidyr)
library(ggnetwork)
library(viridis)
library(riverconn)
library(doParallel)
g <- graph_from_literal(1-+2, 2-+5, 3-+4, 4-+5, 6-+7, 7-+10, 8-+9, 9-+10,
5-+11, 11-+12, 10-+13, 13-+12, 12-+14, 14-+15, 15-+16)
g
# Edges
E(g)
# vertices
V(g)
igraph::as_data_frame(g, what = "edges")
igraph::as_data_frame(g, what = "vertices")
igraph::as_adjacency_matrix(g)
# Decorate edges
E(g)$id_dam <- c(1, NA, 2, 3, NA, 4, NA, 5, 6, NA,  NA, NA, NA, 7, NA)
E(g)$type <- ifelse(is.na(E(g)$id_dam), "joint", "dam")
E(g)
# Decorate vertices
V(g)$length <- c(1, 1, 2, 3, 4, 1, 5, 1, 7, 7, 3, 2, 4, 5, 6, 9)
V(g)$HSI <- c(0.2, 0.1, 0.3, 0.4, 0.5, 0.5, 0.5, 0.6, 0.7, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8)
V(g)$Id <- V(g)$name
V(g)
gg0 <- ggnetwork(g, layout =  layout_as_tree(g %>% as.undirected, root = 16), scale = FALSE)
ggplot(gg0, aes(x = x, y = y, xend = xend, yend = yend)) +
geom_nodes(alpha = 0.3) +
geom_edges(alpha = 0.5,
arrow = arrow(length = unit(10, "pt"), type = "closed"),
aes(color = type)) +
scale_color_viridis(discrete = TRUE)+
geom_nodetext(aes(label = name), fontface = "bold") +
theme_blank()
ggplot(gg0, aes(x = x, y = y, xend = xend, yend = yend)) +
geom_edges(alpha = 0.5,
arrow = arrow(length = unit(10, "pt"), type = "open")) +
geom_nodes(aes(size = length, color = HSI)) +
scale_color_viridis()+
theme_blank()
par(mfrow=c(1,3))
g1 <- set_graph_directionality(g, field_name = "Id", outlet_name = "16")
g2 <- set_graph_directionality(g, field_name = "Id", outlet_name = "5")
plot(as.undirected(g), layout = layout_as_tree(as.undirected(g), root = 8, flip.y = FALSE), main="Undirected graph")
plot(g1, layout = layout_as_tree(as.undirected(g1), root = 16, flip.y = FALSE), main="Outlet = 16")
plot(g2, layout = layout_as_tree(as.undirected(g2), root = 5, flip.y = FALSE), main="Outlet = 5")
# Check edged and nodes attributes
g_v_df <- igraph::as_data_frame(g, what = "vertices")
g_v_df
g_e_df <- igraph::as_data_frame(g, what = "edges") %>%
mutate(pass_u = ifelse(!is.na(id_dam),0.1,NA),
pass_d = ifelse(!is.na(id_dam),0.7,NA))
g_e_df
# Recreate graph
g <- igraph::graph_from_data_frame(d = g_e_df, vertices = g_v_df)
g
index_calculation(g, param = 0.9)
index_calculation(g, B_ij_flag = FALSE)
index_calculation(g, param = 0.9, c_ij_flag = FALSE)
index_calculation(g, c_ij_flag = FALSE,
dir_distance_type = "asymmetric",
disp_type = "threshold", param_u = 0, param_d = 5)
index_calculation(g, c_ij_flag = FALSE,
dir_distance_type = "asymmetric",
disp_type = "threshold", param_u = 5, param_d = 10)
index_calculation(g, c_ij_flag = FALSE,
dir_distance_type = "symmetric",
disp_type = "threshold", param = 10)
index_calculation(g, c_ij_flag = FALSE,
index_type = "reach", index_mode = "to",
dir_distance_type = "asymmetric",
disp_type = "threshold", param_u = 0, param_d = 5)
index_calculation(g, c_ij_flag = FALSE,
dir_distance_type = "asymmetric",
index_type = "reach", index_mode = "to",
disp_type = "threshold", param_u = 5, param_d = 10)
index_calculation(g, c_ij_flag = FALSE,
index_type = "reach", index_mode = "to",
dir_distance_type = "symmetric",
disp_type = "threshold", param = 10)
dams_metadata <- data.frame("id_dam" =  c(1, 2, 3, 4, 5, 6, 7),
"pass_u_updated" = c(1, 1, 1, 1, 1, 1, 1),
"pass_d_updated" = c(1, 1, 1, 1, 1, 1, 1))
dams_metadata
d_index_calculation(g,
dams_metadata,
c_ij_flag = TRUE,
B_ij_flag = TRUE,
parallel = FALSE, ncores = 3,
param_u = 10,  param_d = 10,
index_type = "full",
dir_distance_type = "asymmetric",
disp_type = "threshold")
d_index <- d_index_calculation (g,
dams_metadata,
parallel = FALSE, ncores = 3,
param_u = 10,  param_d = 10,
index_type = "full",
B_ij_flag = FALSE)
# Check edged and nodes attributes
g_v_df <- igraph::as_data_frame(g, what = "vertices")
g_v_df
g_e_df <- igraph::as_data_frame(g, what = "edges") %>%
left_join(d_index, by = "id_dam")
g_e_df
# Recreate graph
g <- igraph::graph_from_data_frame(d = g_e_df, vertices = g_v_df)
g
# Fortify and plot graph
gg0 <- ggnetwork(g, layout =  layout_as_tree(g %>% as.undirected, root = 16), scale = FALSE)
ggplot(gg0, aes(x = x, y = y, xend = xend, yend = yend)) +
geom_edges(alpha = 0.5, size = 3,
arrow = arrow(length = unit(10, "pt"), type = "open"),
aes(color = d_index)) +
geom_nodes() +
scale_color_viridis()+
theme_blank()
setwd("C:/Users/Damiano/Desktop/Andrea debug/fixed debugs")
library(riverconn)
# 17.12.2021
am1<-as.matrix(read.table(file="adj_matrix.txt"))
g1<-graph_from_edgelist(am1)
plot(g1)
components(g1)
is_directed(g1)
vlength1<-read.table(file="centerpoint.txt",header=TRUE)
g2<-set_vertex_attr(g1, name='length', value=vlength1$length)
V(g2)$weight <- strength(g2)
E(g2)$passy<-as.numeric(0.5)
E(g2)$passx<-as.numeric(1)
g3<-set_vertex_attr(g2, name='label', value=paste(1:78))
g4<-set_edge_attr(g3, name='label', value=paste(1:77))
alpha.centrality(g4)
estimate_betweenness(g4, cutoff=1000)
library(rgdal)
library(shp2graph)
library(riverconn)
# 17.12.2021
am1<-as.matrix(read.table(file="adj_matrix.txt"))
g1<-graph_from_edgelist(am1)
plot(g1)
components(g1)
is_directed(g1)
vlength1<-read.table(file="centerpoint.txt",header=TRUE)
g2<-set_vertex_attr(g1, name='length', value=vlength1$length)
V(g2)$weight <- strength(g2)
E(g2)$passy<-as.numeric(0.5)
E(g2)$passx<-as.numeric(1)
g3<-set_vertex_attr(g2, name='label', value=paste(1:78))
g4<-set_edge_attr(g3, name='label', value=paste(1:77))
alpha.centrality(g4)
estimate_betweenness(g4, cutoff=1000)
setwd("C:/Users/Damiano/Desktop/Andrea debug")
library(rgdal)
library(shp2graph)
library(riverconn)
# 17.12.2021
am1<-as.matrix(read.table(file="adj_matrix.txt"))
g1<-graph_from_edgelist(am1)
plot(g1)
components(g1)
is_directed(g1)
vlength1<-read.table(file="centerpoint.txt",header=TRUE)
g2<-set_vertex_attr(g1, name='length', value=vlength1$length)
V(g2)$weight <- strength(g2)
E(g2)$passy<-as.numeric(0.5)
E(g2)$passx<-as.numeric(1)
g3<-set_vertex_attr(g2, name='label', value=paste(1:78))
g4<-set_edge_attr(g3, name='label', value=paste(1:77))
alpha.centrality(g4)
estimate_betweenness(g4, cutoff=1000)
index1<-index_calculation(g4, nodes_id="label", weight = "weight", index_type = "reach", pass_u = "passy",
pass_d = "passx", index_mode = "to", dir_fragmentation_type = "asymmetric",
pass_confluence = 1, field_B = "length", dir_distance_type = "symmetric",
disp_type = "exponential", param=0.5)
g4
index1<-index_calculation(g4, nodes_id="label", weight = "weight", index_type = "reach", pass_u = "passy",
pass_d = "passx", index_mode = "to", dir_fragmentation_type = "asymmetric",
pass_confluence = 1, field_B = "length", dir_distance_type = "asymmetric",
disp_type = "exponential", param_d=0.5, param_u=0.5)
